Non functional Requirements

Maintainability
__________________________________________________________________

In order for a sytem to be maintainable, the system should be both flexible and extensible.  For developers to continue maintenance on the system, it would require that the system should be easy to understand, the technologies used should be available for an extended period of time and developers should be able to easily add new functionality to the system. 

The code tested satisfies the condition that it should be able to understand the system. The system developed is not cluttered and difficult to understand due to good extraction between layers in the Model View Controller model. An obstacle in trying to understand the system is that the code has not been thoroughly documented. This causes some difficulties when trying to gain a better context about certain functions, why they are there and what their purposes are.

The technologies chosen satisfies the requirement of having to be available for a long period of time. The technologies used (such as Node js), are relevantly new platform and therefore they are constantly being updated. This will ensure long use of the technologies, enhancing maintainability.

Developers would be able to easily maintain the code in the sense of adding new features. This is made possible for example by making use of the simple way to add a new route to the program. There might however be slight difficulties when trying to change certain aspects of the system, due to the system being developed too specific, rather than focusing on adaptability. More emphasis was put on being able to easily add to the system, rather than changing the system, though it will still be possible it would only take longer than adding to the system.


Scalability
__________________________________________________________________

In order for a system to be scalable, the system should be able to expand and scale in order to handle a larger load or to serve more clients. 

The system satisfies scalability in the sense that it is currently able to handle all the modules for the computer science department. This is however only a small portion of what the system should be capable of doing. The system should theoretically be able to scale in order to service 50 000 students. This should not be a problem for the system, due to the technologies that it are using. Node js is a lot more scalable than Apache, even though it is only single threaded by default. The use of MongoDB, rather than MySql also increases the scalability of the server [1].  The scalability of Node js can be increased by using multi-core CPUs rather than a single core CPU and load balancers can be implemented. This will ensure that the server application scales more than enough in order to be able to serve the required amount of users. This can however only be done when purchasing more efficient hardware for the host machine. 


Performance
__________________________________________________________________

The performance requirements set out in the formal specification stated that all non reporting operations should respond within less than 0.2 seconds. The specification also stated that report queries should not take any longer than 5 seconds.

The performance testing was done using Firebug for Firefox. Almost all of the non reporting requests responded well under 0.1 seconds. The only cases where the server did not respond fast enough, was when the page was initially requested. The initial page request resulted in a response time of 1.33s which was the worst case. On average the initial request for the homepage resulted in about 305ms response time. 
The next case that took longer than it should, is when a page is requested that does not exist. The reason for this decrease in performance is due to the server searching for a route that does not exist. The server will then eventually just give up and return the error page. This resulted in an average response time of about 286ms. 

The overall average response time for requests is about 150ms as determined by firebug. Below are some screenshots created during the testing of non reporting requests.

The performance for the reporting use cases exceeded expectations by perfoming well under the recommended 5s. This might however change as the database size increases. Testing was limited to the usage of a fairly small size database. 

On average the generating of a report averaged at about 310ms. Below are some screenshots that was taken during the performance testing of the report requests. 



Usability
__________________________________________________________________
The system is usable because firstly the necessary actions that a user can take appear in a navigation bar at the top of the screen. Thus it is easy for a novice user to be able to know what to click on and navigate the website. 

The interface is not cluttered, and only basic functionality is displayed on the home screen, making the system more learnable. The buttons are labelled with text rather than with graphical icons, and the text on the button is quite explanatory, which makes their purpose more clear. 

Larger headings are used to label the different sections, for example under the Manage Constraints tab there are large headings to indicate the Existing constraints section and the Add new constraint section. This again contributes to ease of use for the novice furst year user.

Through these mechanisms the system is memborable hence it is also be understandable.  

Integratibility 
__________________________________________________________________
The system is able to address future integration requirements by providing access to its services using widely adopted public standards such as firstly having seperate npm packages for all the different modules. The packages are stored on Synopia. Also, electrolyte is being used in the server to provide a dependancy injection. The HandleBars server is the main server that needs to be used to test and integrate all the modules on. The routes/index.js, routes/infrastructure.js and routes/content.js files use express to route the different hbs files for the different modules in order to integrate the infrastructure and content subsystems into the main system. 

A seperate file is used to establish the connection to the database to avoid having this done in all the seperate files. Also, global variables are now used such as the global password and username for example. 

A document has been provided via email and a README file has been provided to specify important standards and regulations that must be followed.

The functional code in the seperate packages must be placed in an exportable function taking parameters such as the database or settings, and this is done as part of the electrolyte dependancy injection. 

Exports are also used in the different files to make the code accessible to the other files.


Deployability
__________________________________________________________________
The system is deployable on Linux servers as we have run it using Ubuntu 14.04 Linux and the system was able to run. The following screenshot shows the system running on a Linux server:

The system is deployable on an environment using different databases for persistence of the Buzz datatabase because the Handlebars server contains a folder called node_modules, and it contains the buzz_database package. This package can easily be swopped out andan alternative database package can be plugged in, that the system can use due to the flexibility of this server. As long as the new package has the same name so that the files that require the database do not need to be changed, no major changes will need to be made.  
//screenshot

The system is deployable in environments where the user authentication credentials and roles are sourced from different repositories. The following screenshot indicates that the Handlebars server contains a folder called node_modules, and it contains the buzz_csds package. 
//screenshot

This package can easily be swopped out and an alternative data source package with different credentials and roles can be used, due to the pluggability of the system and dependancy injection employed by the top level team. The new package must just be named the same as the old one to avoid errors where the file is required from the package in the code. 





